import ceil, maxWidth from math
import SetFont, GetTextSize, SetTextPos, SetTextColor, DrawText from surface
import find, gmatch, left, sub from string

char_wrap = (text, width_left, max_width) ->
  total_width = 0
  text = text\gsub '.', (char) ->
    total_width += GetTextSize char
    if total_width >= width_left
      total_width = GetTextSize char
      width_left = max_width
      return "\n#{char}"
    return char
  return text, total_width

wrap_cache = {}
ellipse_cache = {}

global TEXT = {
  DrawSimple: (text, font, x, y, col, x_align, y_align) ->
    SetFont font
    w, h = GetTextSize text
    switch x_align
      when TEXT_ALIGN_CENTER
        x -= w / 2
      when TEXT_ALIGN_RIGHT
        x -= w
    switch y_align
      when TEXT_ALIGN_CENTER
        y -= h / 2
      when TEXT_ALIGN_BOTTOM
        y -= h
    SetTextPos ceil(x), ceil(y)
    import r, g, b, a from col
    SetTextColor r, g, b, a
    DrawText text
    return w, h

  Draw: (text, font, x, y, col, x_align, y_align) ->
    cur_x, cur_y = x, y
    SetFont font
    line_height = select 2, GetTextSize'\n'
    tab_width = 50
    for str in gmatch text, '[^\n]*'
      if #str > 0
        if find str, '\t'
          for tabs, str2 in gmatch str, '(\t*)([^\t]*)'
            cur_x = ceil((cur_x + tab_width * max(#tabs - 1, 0)) / tab_width) * tab_width
            if #str2 > 0
              TEXT.DrawSimple str2, font, cur_x, cur_y, col, x_align
              cur_x += GetTextSize str2
        else
          TEXT.DrawSimple str, font, cur_x, cur_y, col, x_align
      else
        cur_x = x
        cur_y += line_height / 2

  Shadow: (text, font, x, y, col, x_align, y_align, depth, shadow=50) ->
    TEXT.DrawSimple text, font, x + i, y + i, Color(0, 0, 0, i*shadow), x_align, y_align for i=1, depth
    TEXT.DrawSimple text, font, x, y, col, x_align, y_align

  -- This function is horrible. `title`+`subtitle` should be structured objects.
  Dual: (title, subtitle, x=0, y=0) ->
    SetFont title[2]
    th = select 2, GetTextSize title[1]
    SetFont subtitle[2]
    sh = select 2, GetTextSize subtitle[1]
    TEXT.Shadow title[1], title[2], x, y - sh / 2, title[3], title[4], TEXT_ALIGN_CENTER, title[5], title[6]
    TEXT.Shadow subtitle[1], subtitle[2], x, y - th / 2, subtitle[3], subtitle[4], TEXT_ALIGN_CENTER, subtitle[5], subtitle[6]

  Wrap: (text, width, font) ->
    cached = "#{text}#{width}#{font}"
    return wrap_cache[cached] if wrap_cache[cached]
    SetFont font
    tw = GetTextSize text
    if tw <= width
      wrap_cache[cached] = text
      return text
    total_width = 0
    space_width = GetTextSize' '
    text = text\gsub '(%s?[%S]+)', (word) ->
      char = sub word, 1, 1
      total_width = 0 if char in {'\n', '\t'}
      wordlen = GetTextSize word
      total_width += wordlen
      if wordlen
        split_word, split_point = char_wrap word, width - (total_width - wordlen), width
        total_width = split_point
        return split_word
      elseif total_width < width
        return word

      if char == ' '
        total_width = wordlen - space_width
        return "\n#{sub word, 2}"
      total_width = wordlen
      return "\n#{word}"
    wrap_cache[cached] = text
    return text

  Ellipses: (text, width, font) ->
    cached = "#{text}#{width}#{font}"
    return ellipse_cache[cached] if ellipse_cache[cached]
    SetFont font
    tw = GetTextSize text
    if tw <= width
      ellipse_cache[cached] = text
      return text
    inf_loop_prevent = 0 -- just in case we really fuck up
    while true
      text = left text, #text - 1
      text_width = GetTextSize"#{text}..."
      inf_loop_prevent += 1
      break if text_width <= width or inf_loop_prevent > 10000
    text ..= '...'
    ellipse_cache[cached] = text
    return text
}
